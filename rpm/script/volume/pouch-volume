#!/bin/bash

# Copyright 2015 The Kubernetes Authors.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# user can set POUCH_ROOT_OVERRIDE to overwrite the pouch root dir
POUCH_ROOT=${POUCH_ROOT_OVERRIDE:=/home/t4/pouch}
POUCH_GRAPH_ROOT=${POUCH_ROOT}/containerd/root/io.containerd.snapshotter.v1.overlayfs/snapshots

DOCKER_ROOT=${DOCKER_ROOT_OVERRIDE:=/home/t4/docker}
DOCKER_GRAPH_ROOT=${POUCH_ROOT}/overlay

detect_pouch_config() {
    driver=$(pouch info 2>/dev/null | grep -o -P "Storage Driver: (\S+)")
    root_dir=$(pouch info 2>/dev/null | grep -o -P "Pouch Root Dir: (\S+)")
    driver=${driver/Storage Driver: /}
    root_dir=${root_dir/Pouch Root Dir: /}

    if [[ -n "$root_dir" ]];then
        POUCH_ROOT="${root_dir}"
    else
        err "{ \"status\": \"Failure\", \"message\": \"Failed to get root dir of pouch\"}"
        exit 4
    fi

    if [[ "$driver" == "overlayfs" ]]; then
        POUCH_GRAPH_ROOT=${POUCH_ROOT}/containerd/root/io.containerd.snapshotter.v1.overlayfs/snapshots
    elif [[ "$driver" == "overlay1fs" ]]; then
        POUCH_GRAPH_ROOT=${POUCH_ROOT}/containerd/root/io.containerd.snapshotter.v1.overlay1fs/snapshots
    else
        err "{ \"status\": \"Failure\", \"message\": \"Unknown storage driver type ${driver}\"}"
        exit 5
    fi

}


detect_docker_config() {
    driver=$(docker info 2>/dev/null | grep -o -P "Storage Driver: (\S+)")
    root_dir=$(docker info 2>/dev/null | grep -o -P "Docker Root Dir: (\S+)")
    driver=${driver/Storage Driver: /}
    root_dir=${root_dir/Docker Root Dir: /}

    if [[ -n "$root_dir" ]];then
        DOCKER_ROOT="${root_dir}"
    else
        err "{ \"status\": \"Failure\", \"message\": \"Failed to get root dir of docker\"}"
        exit 6
    fi

    if [[ "$driver" == "overlay2" ]]; then
        DOCKER_GRAPH_ROOT=${DOCKER_ROOT}/overlay2
    elif [[ "$driver" == "overlay" ]]; then
        DOCKER_GRAPH_ROOT=${DOCKER_ROOT}/overlay
    else
        err "{ \"status\": \"Failure\", \"message\": \"Unknown storage driver type ${driver}\"}"
        exit 7
    fi

}

shorten_overlay2_layer() {
    local origin_layers=$1
    local lower_path=`echo ${origin_layers} | cut -f 1 -d:`
    local shortened_layers=$(cat `dirname ${lower_path}`/lower 2>/dev/null)
    echo ${shortened_layers}
}

usage() {
    err "Invalid usage. Usage: "
    err "\t$0 init"
    err "\t$0 mount <mount dir> <json params>"
    err "\t$0 unmount <mount dir>"
    exit 1
}

err() {
    echo -ne $* 1>&2
}

log() {
    echo -ne $* >&1
}

# Judge whether a dir is empty
is_empty_dir(){
    return `ls -A $1|wc -w`
}

PYTHON_SCRIPT="import sys;import json;temp = json.loads(sys.argv[1]);print(temp[sys.argv[2]])"

domount() {
    MNTPATH=$1
    if [[ ! -d ${MNTPATH} ]] ; then
        mkdir -p ${MNTPATH} &> /dev/null
    fi

    # Copy initial files from image if MNTPATH is empty.
    if is_empty_dir ${MNTPATH} ; then
        # Get IMAGE and IMAGEPATH from json
        IMAGE=`echo ${PYTHON_SCRIPT} | python - $2 "image"`
        IMAGEPATH=`echo ${PYTHON_SCRIPT} | python - $2 "imagePath"`

        RUNTIME="Docker"
        if command "pouch" &> /dev/null; then
            RUNTIME="Pouch"
        fi

        if [[ "$RUNTIME" = "Docker" ]]; then
            detect_docker_config
            # Make sure image exists
            docker pull ${IMAGE} &> /dev/null
            if [[ ${DOCKER_GRAPH_ROOT} == *overlay2* ]]; then
                mergedPath=`echo ${IMAGE//\//__}`
                mergedDir=${DOCKER_ROOT}/${mergedPath}
                if [[ ! -d ${mergedDir} ]]; then
                    mkdir -p ${mergedDir}
                fi
                if is_empty_dir ${mergedDir}; then
                    # Make sure image exists
                    docker pull ${IMAGE} &> /dev/null
                    cid=`docker create --net host -l type="pouch-volume" ${IMAGE}`
                    if [[ $? -ne 0 ]]; then
                        err "{ \"status\": \"Failure\", \"message\": \"Failed to create container based on $IMAGE\"}"
                        exit 1
                    fi
                    lowerdir=`docker inspect -f '{{.GraphDriver.Data.LowerDir}}' ${cid}`
                    upperdir=`docker inspect -f '{{.GraphDriver.Data.UpperDir}}' ${cid}`
                    workdir=`docker inspect -f '{{.GraphDriver.Data.WorkDir}}' ${cid}`
                    cd ${DOCKER_GRAPH_ROOT}
                    slowerdir=$(shorten_overlay2_layer ${lowerdir})
                    if [[ -z ${slowerdir} ]]; then
                        err "{ \"status\": \"Failure\", \"message\": \"Unable to shorten lowerdir: ${lowerdir}\"}"
                        exit 1
                     fi
                    env PWD=${DOCKER_GRAPH_ROOT} mount -t overlay -o rw,lowerdir=${slowerdir},upperdir=${upperdir},workdir=${workdir} overlay2 ${mergedDir} &> /dev/null
                    if [[ $? -ne 0 ]]; then
                        err "{ \"status\": \"Failure\", \"message\": \"Failed to mount container's dir\"}"
                        docker rm -v ${cid} &> /dev/null
                        exit 1
                    fi
                fi
                if [[ -d ${mergedDir}${IMAGEPATH} ]]; then
                    cp -rp ${mergedDir}${IMAGEPATH} ${MNTPATH}
                fi
                umount ${mergedDir} &> /dev/null
                docker rm -v ${cid} &> /dev/null
            else
                CTHOME=`docker inspect -f "{{.GraphDriver.Data.RootDir}}" ${IMAGE} 2> /dev/null`
                if [[ ${CTHOME} != *overlay*/root ]]; then
                    err "{ \"status\": \"Failure\", \"message\": \"Failed to get root dir from image $IMAGE\"}"
                    exit 1
                fi
                if [[ -d ${CTHOME}${IMAGEPATH} ]]; then
                    cp -rp ${CTHOME}${IMAGEPATH} ${MNTPATH}
                fi
            fi

        else
            detect_pouch_config
            mergedPath=`echo ${IMAGE//\//__}`
            mergedDir=${POUCH_ROOT}/${mergedPath}
            if [[ ! -d ${mergedDir} ]]; then
                mkdir -p ${mergedDir}
            fi
            if is_empty_dir ${mergedDir}; then
                # Make sure image exists
                pouch pull ${IMAGE} &> /dev/null
                cid=`pouch create --net host -l type="pouch-volume" ${IMAGE}`
                if [[ $? -ne 0 ]]; then
                    err "{ \"status\": \"Failure\", \"message\": \"Failed to create container based on $IMAGE\"}"
                    exit 1
                fi
                lowerdir=`pouch inspect -f '{{.Snapshotter.Data.LowerDir}}' ${cid}`
                upperdir=`pouch inspect -f '{{.Snapshotter.Data.UpperDir}}' ${cid}`
                workdir=`pouch inspect -f '{{.Snapshotter.Data.WorkDir}}' ${cid}`
                cd ${POUCH_GRAPH_ROOT}
                slowerdir=`echo ${lowerdir} | sed "s+${POUCH_GRAPH_ROOT}+.+g"`
                env PWD=${POUCH_GRAPH_ROOT} mount -t overlay -o rw,lowerdir=${slowerdir},upperdir=${upperdir},workdir=${workdir} overlay ${mergedDir} &> /dev/null
                if [[ $? -ne 0 ]]; then
                    err "{ \"status\": \"Failure\", \"message\": \"Failed to mount container's dir\"}"
                    pouch rm -v ${cid} &> /dev/null
                    exit 1
                fi
            fi
            if [[ -d ${mergedDir}${IMAGEPATH} ]]; then
                cp -rp ${mergedDir}${IMAGEPATH} ${MNTPATH}
            fi
            umount ${mergedDir} &> /dev/null
            pouch rm -v ${cid} &> /dev/null
        fi
    fi

    log '{"status": "Success"}'
    exit 0
}

unmount() {
    MNTPATH=$1
    # Check MNTPATH is legal because "rm -rf" is dangerous.
    if [[ ${MNTPATH} != */pods/* ]] ; then
        err "{ \"status\": \"Failure\", \"message\": \"Failed to delete path ${MNTPATH}\"}"
        exit 1
    fi

    # We need to remove the content in the MNTPATH, so kubelet can delete the pod successfully.
    rm -rf ${MNTPATH}/* &> /dev/null
    rm -rf ${MNTPATH}/.* &> /dev/null

    log '{"status": "Success"}'
    exit 0
}

op=$1

if [[ "$op" = "init" ]]; then
    log '{"status": "Success", "capabilities": {"attach": false}}'
    exit 0
fi

if [[ $# -lt 2 ]]; then
    usage
fi

shift

case "$op" in
    mount)
        domount $*
        ;;
    unmount)
        unmount $*
        ;;
    *)
        log '{"status": "Not supported"}'
        exit 0
esac

exit 1

