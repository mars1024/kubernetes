package kubelet

import (
	"fmt"
	"path/filepath"
	"strings"
	"time"

	. "github.com/onsi/ginkgo"
	. "github.com/onsi/gomega"
	sigmak8sapi "gitlab.alibaba-inc.com/sigma/sigma-k8s-api/pkg/api"
	"k8s.io/api/core/v1"
	kubeerrors "k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/kubernetes/test/e2e/framework"
	"k8s.io/kubernetes/test/sigma/util"
)

type customCgroupParentTestCase struct {
	pod                 *v1.Pod
	expectedCgrouParent string
}

func getCgroupParent(pod *v1.Pod) string {
	if pod.Status.HostIP == "" {
		framework.Logf("can't get HostIP from pod: %v", pod)
		return ""
	}
	if len(pod.Status.ContainerStatuses) == 0 {
		framework.Logf("Failed to get ContainerStatuses from pod: %v", pod)
		return ""
	}
	segs := strings.Split(pod.Status.ContainerStatuses[0].ContainerID, "//")
	if len(segs) != 2 {
		framework.Logf("Failed to get ContainerID from pod: %v", pod)
		return ""
	}
	containerID := segs[1]
	format := "{{.HostConfig.CgroupParent}}"
	// Get cgroup parent.
	cgroupParent, err := util.GetContainerInspectField(pod.Status.HostIP, containerID, format)
	if err != nil {
		framework.Logf("Failed to get cgroup parent from pod %s: %v", pod.Status.HostIP, err)
		return ""
	}
	return cgroupParent
}

func getSupportedCgroupParents(f *framework.Framework) []string {
	configMapName := "custom-cgroup-parents"
	configMapNamespace := "kube-system"
	configMapKey := "custom-cgroup-parents"
	configMap, err := f.ClientSet.CoreV1().ConfigMaps(configMapNamespace).Get(configMapName, metav1.GetOptions{})
	if err != nil {
		if kubeerrors.IsNotFound(err) {
			framework.Logf("Configmap %s is not existing, create a new one...")
			configMapFileName := "cgroup-parent-configmap.json"
			configMapFile := filepath.Join(util.TestDataDir, configMapFileName)
			configMapJson, err := util.LoadConfigMapFromFile(configMapFile)
			if err != nil {
				framework.Failf("Failed to load configmap from file: %s", configMapFileName)
			}
			configMap, err = f.ClientSet.CoreV1().ConfigMaps(configMapJson.Namespace).Create(configMapJson)
			if err != nil {
				framework.Failf("Failed to create configmap: %v", configMap)
			}
		} else {
			framework.Failf("Failed to get configMap: %s", configMapName)
		}
	}
	customCgroupParentStr, exists := configMap.Data[configMapKey]
	if !exists {
		framework.Failf("Failed to get custom cgroup parent string from configmap: %v", configMap)
	}
	return strings.Split(customCgroupParentStr, ";")
}

func doCustomCgroupParentTestCase(f *framework.Framework, testCase *customCgroupParentTestCase) {
	pod := testCase.pod
	// Step1: Create pod
	testPod, err := f.ClientSet.CoreV1().Pods(f.Namespace.Name).Create(pod)
	Expect(err).NotTo(HaveOccurred(), "create pod err")
	if testCase.expectedCgrouParent == "" {
		err = util.WaitTimeoutForPodStatus(f.ClientSet, testPod, v1.PodRunning, 3*time.Minute)
		Expect(err).To(HaveOccurred(), "invalid cgroup parent, timeout")
		return
	}
	defer util.DeletePod(f.ClientSet, testPod)
	By("wait until pod running and have pod/host IP")
	err = util.WaitTimeoutForPodStatus(f.ClientSet, testPod, v1.PodRunning, 3*time.Minute)
	Expect(err).NotTo(HaveOccurred(), "pod status is not running")
	// Step2: Check created container
	By("check created pod")
	getPod, err := f.ClientSet.CoreV1().Pods(f.Namespace.Name).Get(testPod.Name, metav1.GetOptions{})
	Expect(err).NotTo(HaveOccurred(), "get pod err")
	// Step3: Check cgroup parent after creation
	By("check cgroup parent after creation")
	cgroupParentRaw := getCgroupParent(getPod)
	// There is \n in the end of the reusult generated by staragent.
	// Remove it.
	cgroupParent := strings.Replace(cgroupParentRaw, "\n", "", -1)
	if len(cgroupParent) == 0 {
		framework.Failf("Failed to get cgroup parent when pod is created")
	}
	framework.Logf("Cgroup parent is %s", cgroupParent)
	if strings.HasPrefix(testCase.expectedCgrouParent, "/kubepods") {
		if !strings.HasPrefix(cgroupParent, "/kubepods") {
			framework.Failf("Failed default cgroup parent")
		}
	} else {
		expectedCgroupParent := fmt.Sprintf("%s/%s%s", testCase.expectedCgrouParent, "pod", getPod.UID)
		framework.Logf("Expected cgroup parent is %s", expectedCgroupParent)
		Expect(cgroupParent).Should(Equal(expectedCgroupParent))
	}
}

var _ = Describe("[sigma-kubelet][custom-cgroup-parent] define custom cgroup parent", func() {
	f := framework.NewDefaultFramework("sigma-kubelet")
	It("[smoke] check custom cgroup parent", func() {
		supportedCgroupParents := getSupportedCgroupParents(f)
		if len(supportedCgroupParents) == 0 {
			framework.Failf("Invalid cgroup parent")
		}
		cgroupParent := supportedCgroupParents[0]
		pod := generateRunningPod()
		pod.Annotations[sigmak8sapi.AnnotationPodAllocSpec] = fmt.Sprintf("{\"containers\":[{\"name\":\"pod-base\",\"hostConfig\":{\"cgroupParent\":\"%s\"}}]}", cgroupParent)
		testCase := customCgroupParentTestCase{
			pod:                 pod,
			expectedCgrouParent: cgroupParent,
		}
		doCustomCgroupParentTestCase(f, &testCase)
	})
	It("invalid custom cgroup parent", func() {
		supportedCgroupParents := getSupportedCgroupParents(f)
		if len(supportedCgroupParents) == 0 {
			framework.Failf("Invalid cgroup parent")
		}
		cgroupParent := "onlyfortest"
		pod := generateRunningPod()
		pod.Annotations[sigmak8sapi.AnnotationPodAllocSpec] = fmt.Sprintf("{\"containers\":[{\"name\":\"pod-base\",\"hostConfig\":{\"cgroupParent\":\"%s\"}}]}", cgroupParent)
		testCase := customCgroupParentTestCase{
			pod:                 pod,
			expectedCgrouParent: "/kubepods",
		}
		doCustomCgroupParentTestCase(f, &testCase)
	})
	It("default custom cgroup parent", func() {
		pod := generateRunningPod()
		pod.Annotations[sigmak8sapi.AnnotationPodAllocSpec] = "{\"containers\":[{\"name\":\"pod-base\",\"hostConfig\":{}}]}"
		testCase := customCgroupParentTestCase{
			pod:                 pod,
			expectedCgrouParent: "/kubepods",
		}
		doCustomCgroupParentTestCase(f, &testCase)
	})
})
