/*
Copyright 2017 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// This file was autogenerated by apiregister-gen. Do not edit it manually!

package apps

import (
	"context"
	"fmt"

	"github.com/kubernetes-incubator/apiserver-builder/pkg/builders"
	corev1 "k8s.io/api/core/v1"
	"k8s.io/apimachinery/pkg/apis/meta/internalversion"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/runtime"
	"k8s.io/apimachinery/pkg/runtime/schema"
	utilintstr "k8s.io/apimachinery/pkg/util/intstr"
	"k8s.io/apiserver/pkg/registry/rest"
)

var (
	InternalCafeDeployment = builders.NewInternalResource(
		"cafedeployments",
		"CafeDeployment",
		func() runtime.Object { return &CafeDeployment{} },
		func() runtime.Object { return &CafeDeploymentList{} },
	)
	InternalCafeDeploymentStatus = builders.NewInternalResourceStatus(
		"cafedeployments",
		"CafeDeploymentStatus",
		func() runtime.Object { return &CafeDeployment{} },
		func() runtime.Object { return &CafeDeploymentList{} },
	)
	InternalCafeInPlaceDeployment = builders.NewInternalResource(
		"cafeinplacedeployments",
		"CafeInPlaceDeployment",
		func() runtime.Object { return &CafeInPlaceDeployment{} },
		func() runtime.Object { return &CafeInPlaceDeploymentList{} },
	)
	InternalCafeInPlaceDeploymentStatus = builders.NewInternalResourceStatus(
		"cafeinplacedeployments",
		"CafeInPlaceDeploymentStatus",
		func() runtime.Object { return &CafeInPlaceDeployment{} },
		func() runtime.Object { return &CafeInPlaceDeploymentList{} },
	)
	InternalInPlaceSet = builders.NewInternalResource(
		"inplacesets",
		"InPlaceSet",
		func() runtime.Object { return &InPlaceSet{} },
		func() runtime.Object { return &InPlaceSetList{} },
	)
	InternalInPlaceSetStatus = builders.NewInternalResourceStatus(
		"inplacesets",
		"InPlaceSetStatus",
		func() runtime.Object { return &InPlaceSet{} },
		func() runtime.Object { return &InPlaceSetList{} },
	)
	// Registered resources and subresources
	ApiVersion = builders.NewApiGroup("apps.cafe.cloud.alipay.com").WithKinds(
		InternalCafeDeployment,
		InternalCafeDeploymentStatus,
		InternalCafeInPlaceDeployment,
		InternalCafeInPlaceDeploymentStatus,
		InternalInPlaceSet,
		InternalInPlaceSetStatus,
	)

	// Required by code generated by go2idl
	AddToScheme        = ApiVersion.SchemaBuilder.AddToScheme
	SchemeBuilder      = ApiVersion.SchemaBuilder
	localSchemeBuilder = &SchemeBuilder
	SchemeGroupVersion = ApiVersion.GroupVersion
)

// Required by code generated by go2idl
// Kind takes an unqualified kind and returns a Group qualified GroupKind
func Kind(kind string) schema.GroupKind {
	return SchemeGroupVersion.WithKind(kind).GroupKind()
}

// Required by code generated by go2idl
// Resource takes an unqualified resource and returns a Group qualified GroupResource
func Resource(resource string) schema.GroupResource {
	return SchemeGroupVersion.WithResource(resource).GroupResource()
}

// +genclient
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type CafeInPlaceDeployment struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   CafeInPlaceDeploymentSpec
	Status CafeInPlaceDeploymentStatus
}

// +genclient
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type CafeDeployment struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   CafeDeploymentSpec
	Status CafeDeploymentStatus
}

type CafeInPlaceDeploymentStatus struct {
}

type CafeDeploymentStatus struct {
	ObservedGeneration       int64
	ScheduledReplicas        int32
	AvailableReplicas        int32
	Replicas                 int32
	UpdatedReplicas          int32
	UpdatedReadyReplicas     int32
	UpdatedAvailableReplicas int32
	FullyLableledReplicas    int32
	CollisionCount           *int32
	CurrentRevision          string
	UnitReplicas             map[string]int32
	Conditions               []CafeDeploymentCondition
	ReleaseStatus            *ReleaseStatus
	AutoRescheduleStatus     *AutoRescheduleStatus
}

type CafeDeploymentSpec struct {
	Replicas     int32
	Selector     metav1.LabelSelector
	Template     corev1.PodTemplateSpec
	Topology     Topology
	Strategy     CafeDeploymentUpgradeStrategy
	HistoryLimit int32
}

type AutoRescheduleStatus struct {
	Count              int64
	Progress           AutoScheduleProgress
	LastTransitionTime metav1.Time
}

type CafeDeploymentUpgradeStrategy struct {
	UpgradeType           UpgradeType
	Pause                 bool
	NeedWaitingForConfirm bool
	MinReadySeconds       int32
	BatchSize             *int32
	MaxSurgeSizeInGroup   int32
}

type Topology struct {
	UnitType       UnitType
	Values         []string
	UnitReplicas   map[string]utilintstr.IntOrString
	AutoReschedule *AutoScheduleConfig
}

type ReleaseStatus struct {
	UpdateRevision     string
	CurrentBatchIndex  int32
	CurrentPartitions  map[string]int32
	Progress           ReleaseProgress
	LastTransitionTime metav1.Time
}

type AutoScheduleConfig struct {
	Enable              bool
	InitialDelaySeconds *int32
}

type CafeDeploymentCondition struct {
	Type               CafeDeploymentConditionType
	Status             corev1.ConditionStatus
	LastTransitionTime metav1.Time
	Reason             string
	Message            string
}

type CafeInPlaceDeploymentSpec struct {
}

// +genclient
// +genclient
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type InPlaceSet struct {
	metav1.TypeMeta
	metav1.ObjectMeta
	Spec   InPlaceSetSpec
	Status InPlaceSetStatus
}

type InPlaceSetSpec struct {
	Replicas        int32
	Selector        metav1.LabelSelector
	Template        corev1.PodTemplateSpec
	Strategy        UpgradeStrategy
	MinReadySeconds int32
}

type InPlaceSetStatus struct {
	ObservedGeneration       int64
	ScheduledReplicas        int32
	AvailableReplicas        int32
	Replicas                 int32
	UpdatedReplicas          int32
	UpdatedReadyReplicas     int32
	UpdatedAvailableReplicas int32
	FullyLabeledReplicas     int32
	Conditions               []InPlaceSetCondition
}

type UpgradeStrategy struct {
	Pause     bool
	Partition int32
}

type InPlaceSetCondition struct {
	Type               InPlaceSetConditionType
	Status             corev1.ConditionStatus
	LastTransitionTime metav1.Time
	Reason             string
	Message            string
}

//
// CafeDeployment Functions and Structs
//
// +k8s:deepcopy-gen=false
type CafeDeploymentStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type CafeDeploymentStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type CafeDeploymentList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []CafeDeployment
}

func (CafeDeployment) NewStatus() interface{} {
	return CafeDeploymentStatus{}
}

func (pc *CafeDeployment) GetStatus() interface{} {
	return pc.Status
}

func (pc *CafeDeployment) SetStatus(s interface{}) {
	pc.Status = s.(CafeDeploymentStatus)
}

func (pc *CafeDeployment) GetSpec() interface{} {
	return pc.Spec
}

func (pc *CafeDeployment) SetSpec(s interface{}) {
	pc.Spec = s.(CafeDeploymentSpec)
}

func (pc *CafeDeployment) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *CafeDeployment) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc CafeDeployment) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store CafeDeployment.
// +k8s:deepcopy-gen=false
type CafeDeploymentRegistry interface {
	ListCafeDeployments(ctx context.Context, options *internalversion.ListOptions) (*CafeDeploymentList, error)
	GetCafeDeployment(ctx context.Context, id string, options *metav1.GetOptions) (*CafeDeployment, error)
	CreateCafeDeployment(ctx context.Context, id *CafeDeployment) (*CafeDeployment, error)
	UpdateCafeDeployment(ctx context.Context, id *CafeDeployment) (*CafeDeployment, error)
	DeleteCafeDeployment(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewCafeDeploymentRegistry(sp builders.StandardStorageProvider) CafeDeploymentRegistry {
	return &storageCafeDeployment{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageCafeDeployment struct {
	builders.StandardStorageProvider
}

func (s *storageCafeDeployment) ListCafeDeployments(ctx context.Context, options *internalversion.ListOptions) (*CafeDeploymentList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*CafeDeploymentList), err
}

func (s *storageCafeDeployment) GetCafeDeployment(ctx context.Context, id string, options *metav1.GetOptions) (*CafeDeployment, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*CafeDeployment), nil
}

func (s *storageCafeDeployment) CreateCafeDeployment(ctx context.Context, object *CafeDeployment) (*CafeDeployment, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*CafeDeployment), nil
}

func (s *storageCafeDeployment) UpdateCafeDeployment(ctx context.Context, object *CafeDeployment) (*CafeDeployment, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*CafeDeployment), nil
}

func (s *storageCafeDeployment) DeleteCafeDeployment(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, &metav1.DeleteOptions{})
	return sync, err
}

//
// CafeInPlaceDeployment Functions and Structs
//
// +k8s:deepcopy-gen=false
type CafeInPlaceDeploymentStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type CafeInPlaceDeploymentStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type CafeInPlaceDeploymentList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []CafeInPlaceDeployment
}

func (CafeInPlaceDeployment) NewStatus() interface{} {
	return CafeInPlaceDeploymentStatus{}
}

func (pc *CafeInPlaceDeployment) GetStatus() interface{} {
	return pc.Status
}

func (pc *CafeInPlaceDeployment) SetStatus(s interface{}) {
	pc.Status = s.(CafeInPlaceDeploymentStatus)
}

func (pc *CafeInPlaceDeployment) GetSpec() interface{} {
	return pc.Spec
}

func (pc *CafeInPlaceDeployment) SetSpec(s interface{}) {
	pc.Spec = s.(CafeInPlaceDeploymentSpec)
}

func (pc *CafeInPlaceDeployment) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *CafeInPlaceDeployment) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc CafeInPlaceDeployment) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store CafeInPlaceDeployment.
// +k8s:deepcopy-gen=false
type CafeInPlaceDeploymentRegistry interface {
	ListCafeInPlaceDeployments(ctx context.Context, options *internalversion.ListOptions) (*CafeInPlaceDeploymentList, error)
	GetCafeInPlaceDeployment(ctx context.Context, id string, options *metav1.GetOptions) (*CafeInPlaceDeployment, error)
	CreateCafeInPlaceDeployment(ctx context.Context, id *CafeInPlaceDeployment) (*CafeInPlaceDeployment, error)
	UpdateCafeInPlaceDeployment(ctx context.Context, id *CafeInPlaceDeployment) (*CafeInPlaceDeployment, error)
	DeleteCafeInPlaceDeployment(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewCafeInPlaceDeploymentRegistry(sp builders.StandardStorageProvider) CafeInPlaceDeploymentRegistry {
	return &storageCafeInPlaceDeployment{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageCafeInPlaceDeployment struct {
	builders.StandardStorageProvider
}

func (s *storageCafeInPlaceDeployment) ListCafeInPlaceDeployments(ctx context.Context, options *internalversion.ListOptions) (*CafeInPlaceDeploymentList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*CafeInPlaceDeploymentList), err
}

func (s *storageCafeInPlaceDeployment) GetCafeInPlaceDeployment(ctx context.Context, id string, options *metav1.GetOptions) (*CafeInPlaceDeployment, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*CafeInPlaceDeployment), nil
}

func (s *storageCafeInPlaceDeployment) CreateCafeInPlaceDeployment(ctx context.Context, object *CafeInPlaceDeployment) (*CafeInPlaceDeployment, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*CafeInPlaceDeployment), nil
}

func (s *storageCafeInPlaceDeployment) UpdateCafeInPlaceDeployment(ctx context.Context, object *CafeInPlaceDeployment) (*CafeInPlaceDeployment, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*CafeInPlaceDeployment), nil
}

func (s *storageCafeInPlaceDeployment) DeleteCafeInPlaceDeployment(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, &metav1.DeleteOptions{})
	return sync, err
}

//
// InPlaceSet Functions and Structs
//
// +k8s:deepcopy-gen=false
type InPlaceSetStrategy struct {
	builders.DefaultStorageStrategy
}

// +k8s:deepcopy-gen=false
type InPlaceSetStatusStrategy struct {
	builders.DefaultStatusStorageStrategy
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object

type InPlaceSetList struct {
	metav1.TypeMeta
	metav1.ListMeta
	Items []InPlaceSet
}

func (InPlaceSet) NewStatus() interface{} {
	return InPlaceSetStatus{}
}

func (pc *InPlaceSet) GetStatus() interface{} {
	return pc.Status
}

func (pc *InPlaceSet) SetStatus(s interface{}) {
	pc.Status = s.(InPlaceSetStatus)
}

func (pc *InPlaceSet) GetSpec() interface{} {
	return pc.Spec
}

func (pc *InPlaceSet) SetSpec(s interface{}) {
	pc.Spec = s.(InPlaceSetSpec)
}

func (pc *InPlaceSet) GetObjectMeta() *metav1.ObjectMeta {
	return &pc.ObjectMeta
}

func (pc *InPlaceSet) SetGeneration(generation int64) {
	pc.ObjectMeta.Generation = generation
}

func (pc InPlaceSet) GetGeneration() int64 {
	return pc.ObjectMeta.Generation
}

// Registry is an interface for things that know how to store InPlaceSet.
// +k8s:deepcopy-gen=false
type InPlaceSetRegistry interface {
	ListInPlaceSets(ctx context.Context, options *internalversion.ListOptions) (*InPlaceSetList, error)
	GetInPlaceSet(ctx context.Context, id string, options *metav1.GetOptions) (*InPlaceSet, error)
	CreateInPlaceSet(ctx context.Context, id *InPlaceSet) (*InPlaceSet, error)
	UpdateInPlaceSet(ctx context.Context, id *InPlaceSet) (*InPlaceSet, error)
	DeleteInPlaceSet(ctx context.Context, id string) (bool, error)
}

// NewRegistry returns a new Registry interface for the given Storage. Any mismatched types will panic.
func NewInPlaceSetRegistry(sp builders.StandardStorageProvider) InPlaceSetRegistry {
	return &storageInPlaceSet{sp}
}

// Implement Registry
// storage puts strong typing around storage calls
// +k8s:deepcopy-gen=false
type storageInPlaceSet struct {
	builders.StandardStorageProvider
}

func (s *storageInPlaceSet) ListInPlaceSets(ctx context.Context, options *internalversion.ListOptions) (*InPlaceSetList, error) {
	if options != nil && options.FieldSelector != nil && !options.FieldSelector.Empty() {
		return nil, fmt.Errorf("field selector not supported yet")
	}
	st := s.GetStandardStorage()
	obj, err := st.List(ctx, options)
	if err != nil {
		return nil, err
	}
	return obj.(*InPlaceSetList), err
}

func (s *storageInPlaceSet) GetInPlaceSet(ctx context.Context, id string, options *metav1.GetOptions) (*InPlaceSet, error) {
	st := s.GetStandardStorage()
	obj, err := st.Get(ctx, id, options)
	if err != nil {
		return nil, err
	}
	return obj.(*InPlaceSet), nil
}

func (s *storageInPlaceSet) CreateInPlaceSet(ctx context.Context, object *InPlaceSet) (*InPlaceSet, error) {
	st := s.GetStandardStorage()
	obj, err := st.Create(ctx, object, nil, &metav1.CreateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*InPlaceSet), nil
}

func (s *storageInPlaceSet) UpdateInPlaceSet(ctx context.Context, object *InPlaceSet) (*InPlaceSet, error) {
	st := s.GetStandardStorage()
	obj, _, err := st.Update(ctx, object.Name, rest.DefaultUpdatedObjectInfo(object), nil, nil, false, &metav1.UpdateOptions{})
	if err != nil {
		return nil, err
	}
	return obj.(*InPlaceSet), nil
}

func (s *storageInPlaceSet) DeleteInPlaceSet(ctx context.Context, id string) (bool, error) {
	st := s.GetStandardStorage()
	_, sync, err := st.Delete(ctx, id, &metav1.DeleteOptions{})
	return sync, err
}
